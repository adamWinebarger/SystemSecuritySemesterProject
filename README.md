# SystemSecuritySemesterProject

This project looks to examine practical applications of various cryptographic schemes into real-world (WPF) applications.

Prior to this project, I created a project for another class that made use an a Symmetric (AES) encrpytion scheme in which data was encrypted using a shared secret key stored within the source code of said project and decrypted using the same key but stored on a detachable USB thumb drive. While better than nothing, it meant that someone who knew where to look within the source code of a project could pretty easily figure out what the key used to decrypt was and what would needed to be done to create a passable fake decryption key. 

In changing this project's cryptographic scheme to something asymmetric, we can make the encryption scheme more secure as the keys used to encrypt and decrypt will be different - meaning that knowledge of the public key stored within the source files will not allow an adversarial party to decrypt encrypted files on the machine. Furthermore, we could make security on the application even more robust by either using AES to encrypt our public and private key values, or simply use an asymmetric scheme to encrypt the AES key - although the latter may pose an issue since there would have to be some way to decrypt the encryption key on the device itself; meaning there would be a way for an attacker to figure out the key needed to decrypt files.

In addition, one of the other major shortcomings of the previously mentioned project was the fact that it would attempt to decrypt using any file called "Key.txt" on a detachable medium - leading to the program crashing in the event that the contents of key.txt was not the key needed to decrypt. So in order to counteract this, some sort of hashing/signature scheme seems like it would be useful. At the time of writing this, the rough scheme I'm thinking of right now is storing a hashed value of the public key on a corresponding private key thumb-drive and using that as a check to ensure that the public and private keys correspond. 

# What was done

The original idea of the project was to convert the BAARS4 Tester from a symmetric encryption scheme to an asymmetric one - as the whole idea of having an encryption key within the source files and a decryption key on a detachable medium was formulated with asymmetric encryption in mind. For this, one of the biggest challenges was figuring out how to implement an asymmetric cryptographic scheme. Since Microsoft's documentation for asymmetric crypto are... not the greatest and the examples are generic, my next step was asking the internet for help. This yielded poor results as any implementation by chatGPT was non-functional and the people of r/csharp flat out said I should not be trying to do this with RSA. When inspiration finally came, it was looking at openssl's implementation of RSA for encryption/decryption of textfiles on the Unix command line. Given its use of .pem files for storing relevent data pertaining to the keys, I started setting out looking for a way to incorporate the use of .pem files into this program... then I found out that RSACryptoService providor has had and ImportFromPem function since .NET 5.0. 

Since I didn't want to make sweeping changes to my original program before I was certain it would work (even though that's like the entire point of github), I decided to build a couple programs from scratch - first a few CLI programs because I didn't feel like messing with graphical components right off the bat, and then a GUI-based program (The RSA Text Encryptor) to really test out the idea of encrypting plaintext with a key in the source files and decrypting it on a detachable. 

There isn't really much to say about the RSA text encryptor since my idea worked. This was basically a stepping stone towards implementing my idea in the BAARS4 Tester. But having done that as a standalone program first meant that I had a few usable functions for RSA encryption/decryption that I was able to swap and drop into the BAARS4 tester with a minimal amount of modification. From there, a few limitations emerged - most notably the fact that RSA can't encrypt anything longer than its key length. So while the AES encryptor was able to encrypt the contents of a text file as a single string without issue, the RSA variation began running into bad length errors when I attempted to implement this scheme into the tester. This was remedied by passing the contents of the textfile as an array of type string and encrypting each line piecemeal. 

# How to use

Since this program was built using WPF, this is pretty much exclusively a Windows program. But in both cases, if you click the folders of the program names (there should be ~3 layers of folders of the name of the program), then \bin\debug\net[version]windows there is an will be an executable within that folder that will launch the program (assuming you have the correct version of .NET installed). From there, as long as the file titled privKey.pem is on a detachable media (in drives D thru J), then the program will be able to decrypt the contents of the textfiles (if it's the BAARS tester) or the strings stored in memory of the RSA text encryptor. It will, however, not decrypt anything if there is not that pem file on a detachable drive or if the key value is incorrect. 

If you are looking to change the key values, you will need to delete all of the directories within \bin\debug\net5.0windows\Tester_Profiles or it will attempt to decrypt them with the wrong key. From there, you will need to add a Sha256 hash to \bin\debug\net5.0windows\Key\privkeyhash.txt generated with the hash generator included within this git repo and the pem conetents to \bin\debug\net5.0windows\Key\pubkey.pem and then the private key values to the privkey.pem file stored on your detachable media. 

For changing keys on the RSA text encryptor, the steps are relatively the same, though there is nothing to delete and the hash text file is \bin\debug\net6.0windows

# What I would like to do next

Since this is not the most efficient way to encrypt things - and kind of underkill AND overkill for encrypting textfiles with sensitive patient information, there are a few things I would like to do with this in the futre:

In order to provide multi-key support, I think it would be a good idea to include a hash of the public key used to encrypt tester data within that tester's directory. This way, the program could have multi-key support and a way to differentiate between what key was used to encrypt and which key should be used to decrypt the contents of a given tester directory. In addition, I think that the encryption scheme could be handled a few different ways: either using EC w/ Diffie-Hellman to encrypt and decrypt everything, or by using an asymmetric scheme to encrypt an AES key, the decrypted version of which would be used for the actual encryption/decryption of tester information
